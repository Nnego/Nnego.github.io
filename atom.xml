<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://suxiaomu.top</id>
    <title>苏小霂的博客</title>
    <updated>2025-03-09T02:41:55.965Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://suxiaomu.top"/>
    <link rel="self" href="https://suxiaomu.top/atom.xml"/>
    <logo>https://suxiaomu.top/images/avatar.png</logo>
    <icon>https://suxiaomu.top/favicon.ico</icon>
    <rights>All rights reserved 2025, 苏小霂的博客</rights>
    <entry>
        <title type="html"><![CDATA[常见分布式事务解决方案]]></title>
        <id>https://suxiaomu.top/oxda6OkfFf/</id>
        <link href="https://suxiaomu.top/oxda6OkfFf/">
        </link>
        <updated>2023-07-11T02:23:27.000Z</updated>
        <summary type="html"><![CDATA[<p>在微服务架构中实现分布式事务是解决跨服务数据一致性的重要问题，由于微服务通常涉及多个独立部署的服务和数据库，传统的ACID（原子性、一致性、隔离性、持久性）特性难以直接应用。常见的分布式事务解决方案及其优缺点分析：</p>
]]></summary>
        <content type="html"><![CDATA[<p>在微服务架构中实现分布式事务是解决跨服务数据一致性的重要问题，由于微服务通常涉及多个独立部署的服务和数据库，传统的ACID（原子性、一致性、隔离性、持久性）特性难以直接应用。常见的分布式事务解决方案及其优缺点分析：</p>
<!-- more -->
<hr>
<h3 id="1-基于消息队列的最终一致性"><strong>1. 基于消息队列的最终一致性</strong></h3>
<p><strong>实现方式：</strong><br>
通过异步消息传递（如Kafka、RabbitMQ等）协调多个服务，结合本地事务和补偿机制保证最终一致性。</p>
<h4 id="优点"><strong>优点：</strong></h4>
<ul>
<li><strong>解耦性强</strong>：服务之间通过事件驱动通信，降低直接依赖。</li>
<li><strong>高可用性</strong>：消息队列本身具备重试、死信队列等功能，可应对网络波动。</li>
<li><strong>简单易用</strong>：实现相对容易，适合低频事务场景。</li>
</ul>
<h4 id="缺点"><strong>缺点：</strong></h4>
<ul>
<li><strong>一致性延迟</strong>：最终一致性的达成需要时间，无法保证强一致。</li>
<li><strong>重复消费问题</strong>：需处理消息重复投递（如幂等性设计）。</li>
<li><strong>协调复杂度高</strong>：依赖业务逻辑自行实现补偿机制（如回滚操作）。</li>
</ul>
<hr>
<h3 id="2-saga模式"><strong>2. Saga模式</strong></h3>
<p><strong>实现方式：</strong><br>
将长事务拆分为多个本地事务（称为“Saga”），通过正向操作和反向补偿操作保证最终一致性。有两种变体：</p>
<ul>
<li><strong>编排式（Orchestration）</strong>：由中央协调器控制所有服务的执行顺序。</li>
<li><strong>编舞式（Choreography）</strong>：各服务自行决定下一步操作，通过消息通知驱动。</li>
</ul>
<h4 id="优点-2"><strong>优点：</strong></h4>
<ul>
<li><strong>灵活解耦</strong>：各服务自主决策，无需强中心化协调器。</li>
<li><strong>支持回滚</strong>：通过补偿事务（如退款、撤销订单）处理失败场景。</li>
<li><strong>可扩展性好</strong>：适合复杂业务流程的拆分。</li>
</ul>
<h4 id="缺点-2"><strong>缺点：</strong></h4>
<ul>
<li><strong>逻辑复杂度高</strong>：需要设计正向和反向操作，且需保证原子性。</li>
<li><strong>状态管理困难</strong>：需跟踪事务状态（如已执行、待补偿）。</li>
<li><strong>一致性延迟</strong>：补偿机制可能无法实时生效。</li>
</ul>
<hr>
<h3 id="3-两阶段提交2pc2phase-commit"><strong>3. 两阶段提交（2PC/2Phase Commit）</strong></h3>
<p><strong>实现方式：</strong><br>
通过协调者（Coordinator）和参与者（Participants）的协作确保所有服务一致提交或回滚：</p>
<ol>
<li><strong>准备阶段</strong>：协调者通知各服务预提交，等待确认。</li>
<li><strong>提交阶段</strong>：若所有参与者确认，则正式提交；否则全部回滚。</li>
</ol>
<h4 id="优点-3"><strong>优点：</strong></h4>
<ul>
<li><strong>强一致性保证</strong>：理论上可实现ACID特性。</li>
<li><strong>简单直接</strong>：适用于少量服务的事务场景。</li>
</ul>
<h4 id="缺点-3"><strong>缺点：</strong></h4>
<ul>
<li><strong>性能差</strong>：等待锁和网络延迟导致吞吐量低。</li>
<li><strong>单点故障风险</strong>：协调者失效可能导致系统阻塞（如脑裂问题）。</li>
<li><strong>不适合微服务架构</strong>：强一致性需求与分布式系统的CAP定理冲突，适用于传统单体或少量节点。</li>
</ul>
<hr>
<h3 id="4-三阶段提交3pc3phase-commit"><strong>4. 三阶段提交（3PC/3Phase Commit）</strong></h3>
<p><strong>实现方式：</strong><br>
在2PC基础上增加“CanCommit”预准备阶段，减少协调者故障时的阻塞问题：</p>
<ol>
<li><strong>CanCommit</strong>：参与者检查是否可提交。</li>
<li><strong>PreCommit</strong>：协调者通知参与者预提交。</li>
<li><strong>Commit/Rollback</strong>：根据超时或响应决定最终状态。</li>
</ol>
<h4 id="优点-4"><strong>优点：</strong></h4>
<ul>
<li><strong>降低脑裂风险</strong>：通过超时机制减少协调者故障的影响。</li>
</ul>
<h4 id="缺点-4"><strong>缺点：</strong></h4>
<ul>
<li><strong>复杂度更高</strong>：实现和维护难度大，仍存在性能瓶颈。</li>
<li><strong>实际应用少</strong>：工业界较少使用，更多停留在理论层面。</li>
</ul>
<hr>
<h3 id="5-tcc模式try-confirm-cancel"><strong>5. TCC模式（Try-Confirm-Cancel）</strong></h3>
<p><strong>实现方式：</strong><br>
通过三个阶段保证最终一致性：</p>
<ol>
<li><strong>Try</strong>：检查资源并预留（如扣减库存但未提交事务）。</li>
<li><strong>Confirm</strong>：正式执行业务操作（提交事务）。</li>
<li><strong>Cancel</strong>：取消Try阶段的操作（回滚预留资源）。</li>
</ol>
<h4 id="优点-5"><strong>优点：</strong></h4>
<ul>
<li><strong>强控制能力</strong>：可精确管理每个步骤的执行和补偿。</li>
<li><strong>支持复杂场景</strong>：适合需要严格资源管控的业务（如金融交易）。</li>
</ul>
<h4 id="缺点-5"><strong>缺点：</strong></h4>
<ul>
<li><strong>侵入性强</strong>：需在业务代码中实现Try、Confirm、Cancel逻辑，耦合度高。</li>
<li><strong>协调器依赖</strong>：仍需中心化组件管理状态流转。</li>
</ul>
<hr>
<h3 id="6-分布式事务框架如seatatccl"><strong>6. 分布式事务框架（如Seata/TCCL）</strong></h3>
<p><strong>实现方式：</strong><br>
使用开源框架（如阿里巴巴的Seata）提供统一的分布式事务解决方案。支持多种模式：</p>
<ul>
<li><strong>AT模式</strong>：基于数据库的行级锁和二阶段提交。</li>
<li><strong>TCC模式</strong>：与上述TCC模式结合，提供框架支持。</li>
<li><strong>Saga模式</strong>：通过事件消息实现最终一致性。</li>
</ul>
<h4 id="优点-6"><strong>优点：</strong></h4>
<ul>
<li><strong>开箱即用</strong>：封装了复杂逻辑，降低开发成本。</li>
<li><strong>兼容性强</strong>：支持主流数据库和中间件（如MySQL、RocketMQ）。</li>
<li><strong>灵活性高</strong>：可切换不同事务模式适应业务需求。</li>
</ul>
<h4 id="缺点-6"><strong>缺点：</strong></h4>
<ul>
<li><strong>学习曲线陡峭</strong>：需理解框架原理及配置细节。</li>
<li><strong>资源开销</strong>：引入额外组件（如TC服务器），增加系统复杂度。</li>
<li><strong>依赖第三方库</strong>：可能存在兼容性或版本问题。</li>
</ul>
<hr>
<h3 id="选择方案的权衡因素"><strong>选择方案的权衡因素</strong></h3>
<table>
<thead>
<tr>
<th>方案</th>
<th>一致性保证</th>
<th>性能</th>
<th>复杂度</th>
<th>场景示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息队列（最终一致）</td>
<td>最终一致</td>
<td>高</td>
<td>中等</td>
<td>订单创建通知</td>
</tr>
<tr>
<td>Saga模式</td>
<td>最终一致</td>
<td>中低</td>
<td>高</td>
<td>复杂流程拆分</td>
</tr>
<tr>
<td>2PC/3PC</td>
<td>强一致</td>
<td>极差</td>
<td>非常高</td>
<td>少量服务的严格场景</td>
</tr>
<tr>
<td>TCC框架</td>
<td>可靠最终一致</td>
<td>中等</td>
<td>较高</td>
<td>金融交易</td>
</tr>
<tr>
<td>Seata (AT模式)</td>
<td>类强一致</td>
<td>中等</td>
<td>中等</td>
<td>多数据库操作</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="最佳实践建议"><strong>最佳实践建议</strong></h3>
<ol>
<li><strong>优先考虑业务场景</strong>：
<ul>
<li>对一致性要求极高的核心业务（如支付），可尝试TCC或Seata的AT模式。</li>
<li>非实时性需求（如日志同步、统计）适合消息队列+最终一致。</li>
</ul>
</li>
<li><strong>避免过度设计</strong>：简单场景无需引入复杂框架，保持系统简洁。</li>
<li><strong>监控与回滚机制</strong>：无论采用何种方案，均需配套补偿策略（如失败重试、人工介入）。</li>
</ol>
<hr>
<p>通过以上分析，可根据业务需求和团队能力选择最合适的分布式事务解决方案。在微服务架构中，最终一致性和松耦合通常是更优的选择，而强一致性则应谨慎使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射、动态代理与AOP]]></title>
        <id>https://suxiaomu.top/_jvAm-ipjT/</id>
        <link href="https://suxiaomu.top/_jvAm-ipjT/">
        </link>
        <updated>2023-06-18T15:52:14.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<hr>
<h3 id="一-什么是反射优缺点"><strong>一、什么是反射？优缺点</strong></h3>
<h4 id="反射reflection"><strong>反射（Reflection）</strong></h4>
<ul>
<li><strong>定义</strong>：Java反射机制允许程序在运行时获取自身的信息，并操作对象的属性和方法，即使这些信息原本是私有的。</li>
<li><strong>核心API</strong>：
<ul>
<li><code>Class</code>类：获取类的元数据（如构造器、方法、字段）。</li>
<li><code>Field</code>：访问类的成员变量。</li>
<li><code>Method</code>：调用类的方法。</li>
</ul>
</li>
</ul>
<h4 id="优点"><strong>优点</strong></h4>
<ol>
<li><strong>灵活性</strong>：在运行时动态操作对象，无需提前硬编码。</li>
<li><strong>框架实现基础</strong>：Spring等框架依赖反射进行依赖注入、AOP代理生成。</li>
<li><strong>调试和工具开发</strong>：用于生成代码文档（如Javadoc）、序列化/反序列化。</li>
</ol>
<h4 id="缺点"><strong>缺点</strong></h4>
<ol>
<li><strong>性能开销高</strong>：反射操作比直接调用方法慢，频繁使用会显著降低效率。</li>
<li><strong>破坏封装性</strong>：可以访问私有成员，可能违反设计原则。</li>
<li><strong>编译时检查缺失</strong>：错误在运行时才会暴露（如方法名拼写错误）。</li>
</ol>
<hr>
<h3 id="二-jdk动态代理-vs-cglib动态代理"><strong>二、JDK动态代理 vs CGLIB动态代理</strong></h3>
<h4 id="1-jdk动态代理"><strong>1. JDK动态代理</strong></h4>
<ul>
<li><strong>实现原理</strong>：
<ul>
<li>基于<code>java.lang.reflect.Proxy</code>类，生成一个目标接口的代理实例。</li>
<li>要求目标对象必须<strong>实现至少一个接口</strong>。</li>
</ul>
</li>
<li><strong>步骤</strong>：<pre><code class="language-java">// 创建InvocationHandler（处理方法调用）
InvocationHandler handler = new MyInvocationHandler(target);

// 根据接口生成代理类
Class&lt;?&gt; proxyClass = Proxy.getProxyClass(loader, interfaces);

// 创建代理实例并返回
return (T) proxyClass.getConstructor(InvocationHandler.class).newInstance(handler);
</code></pre>
</li>
<li><strong>适用场景</strong>：目标对象实现了接口的情况。</li>
</ul>
<h4 id="2-cglib动态代理"><strong>2. CGLIB动态代理</strong></h4>
<ul>
<li><strong>实现原理</strong>：
<ul>
<li>使用<code>net.sf.cglib.proxy.Enhancer</code>生成一个子类（非接口）的代理。</li>
<li><strong>无需目标对象实现接口</strong>，但目标类不能是<code>final</code>且方法不能是<code>private</code>或<code>static</code>。</li>
</ul>
</li>
<li><strong>步骤</strong>：<pre><code class="language-java">Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(target.getClass());
enhancer.setCallback(new MethodInterceptor() {
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 执行方法前逻辑（如日志）
        return method.invoke(target, args); // 调用目标对象的方法
    }
});

return (T) enhancer.create();
</code></pre>
</li>
<li><strong>适用场景</strong>：目标对象未实现接口的情况。</li>
</ul>
<h4 id="对比总结"><strong>对比总结</strong></h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>JDK动态代理</th>
<th>CGLIB动态代理</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现方式</td>
<td>接口代理</td>
<td>子类继承</td>
</tr>
<tr>
<td>是否需要接口</td>
<td>必须</td>
<td>不需要</td>
</tr>
<tr>
<td>性能</td>
<td>较慢（反射）</td>
<td>更快但比直接调用仍慢</td>
</tr>
<tr>
<td>适用场景</td>
<td>接口场景</td>
<td>非接口场景</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="三-什么是aop如何实现"><strong>三、什么是AOP？如何实现？</strong></h3>
<h4 id="1-aop面向切面编程"><strong>1. AOP（面向切面编程）</strong></h4>
<ul>
<li><strong>定义</strong>：将横切关注点（如日志、事务、权限控制）从业务代码中分离，提高模块化。</li>
<li><strong>核心概念</strong>：
<ul>
<li><strong>切面（Aspect）</strong>：封装了横切逻辑的类（如日志功能）。</li>
<li><strong>连接点（Join Point）</strong>：程序执行过程中的某个具体位置（如方法调用、异常抛出）。</li>
<li><strong>切入点（Pointcut）</strong>：匹配一组切点的表达式（如<code>execution(* com.example.service.*.*(..))</code>）。</li>
<li><strong>通知（Advice）</strong>：在特定连接点执行的操作，类型包括：
<ul>
<li><code>Before</code>：方法前执行</li>
<li><code>AfterReturning</code>：方法正常返回后执行</li>
<li><code>AfterThrowing</code>：抛出异常时执行</li>
<li><code>Around</code>：环绕目标方法（可控制是否执行）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-aop实现方式"><strong>2. AOP实现方式</strong></h4>
<ul>
<li>
<p><strong>静态代理</strong>：</p>
<ul>
<li>手动为每个类创建代理，代码冗余。</li>
</ul>
</li>
<li>
<p><strong>动态代理（主流）</strong>：</p>
<ul>
<li><strong>JDK动态代理 + CGLIB</strong>：Spring默认使用两者结合（接口用JDK，无接口用CGLIB）。</li>
<li><strong>AspectJ</strong>：编译时或加载时织入切面，性能更高。</li>
</ul>
</li>
</ul>
<h4 id="3-spring-aop实现流程"><strong>3. Spring AOP实现流程</strong></h4>
<ol>
<li>定义切面类（如<code>@Aspect</code>标注），包含通知逻辑。</li>
<li>配置切入点表达式（如使用<code>@Pointcut</code>）。</li>
<li>Spring容器在启动时通过动态代理生成代理对象，将切面织入目标对象。</li>
</ol>
<hr>
<h3 id="四-aop与动态代理的关系"><strong>四、AOP与动态代理的关系</strong></h3>
<ul>
<li><strong>AOP依赖动态代理</strong>：Spring AOP默认通过JDK或CGLIB动态代理实现切面的织入（Weaving）。</li>
<li><strong>织入时机</strong>：
<ul>
<li><strong>运行时</strong>：Spring在初始化Bean时生成代理对象。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="五-示例代码"><strong>五、示例代码</strong></h3>
<h4 id="1-使用spring-aspect实现aop"><strong>1. 使用Spring @Aspect实现AOP</strong></h4>
<pre><code class="language-java">// 定义切面类
@Aspect
@Component
public class LoggingAspect {
    @Before(&quot;execution(* com.example.service.*.*(..))&quot;) // 切入点表达式
    public void logBefore(JoinPoint joinPoint) {
        System.out.println(&quot;方法调用前：&quot; + joinPoint.getSignature().getName());
    }
}
</code></pre>
<h4 id="2-spring配置"><strong>2. Spring配置</strong></h4>
<pre><code class="language-java">@Configuration
@EnableAspectJAutoProxy // 开启AOP支持
public class AppConfig { 
    @Bean
    public UserService userService() {
        return new UserServiceImpl();
    }

    @Bean
    public LoggingAspect loggingAspect() {
        return new LoggingAspect();
    }
}
</code></pre>
<hr>
<h3 id="六-总结"><strong>六、总结</strong></h3>
<ul>
<li><strong>反射</strong>：运行时动态操作类，但性能较低。</li>
<li><strong>动态代理</strong>：
<ul>
<li>JDK（接口）和CGLIB（无接口）是两种实现方式。</li>
</ul>
</li>
<li><strong>AOP</strong>：
<ul>
<li>核心思想是模块化横切关注点，依赖动态代理实现织入。</li>
</ul>
</li>
</ul>
<hr>
<details type="reasoning" done="true" duration="25">
<summary>Thought for 25 seconds</summary>
> 好的，我现在需要帮助这位Java开发人员解答他在面试中遇到的问题。这些问题涉及反射、动态代理、AOP及其相关知识点，还有一些具体的对比和区别。
> 
> 首先，我应该逐个问题来分析，确保每个点都解释清楚，并且提供相关的补充知识。这样可以帮助他全面理解这些概念，为未来的面试或工作做好准备。
> 
> 1. **什么是反射？优缺点**
>    - 反射机制是Java的一个强大功能，允许程序在运行时检查和操作类、方法和字段等元数据。
>    - 优点包括灵活性高、便于框架实现，缺点则是性能开销较大，可能破坏封装性。
> 
> 2. **JDK动态代理和CGLIB动态代理**
>    - JDK动态代理基于`java.lang.reflect.Proxy`，需要目标对象实现接口。
>    - CGLIB通过生成子类代理，无需接口支持，但对某些情况有限制（如final类）。
> 
> 3. **什么是AOP？如何实现**
>    - AOP将横切关注点从业务逻辑中分离，常见的有日志、事务管理等。
>    - 实现方式包括动态代理和静态代理，其中Spring常用动态代理来实现AOP。
> 
> 4. **AOP框架有哪些**
>    - 主要有Spring AOP和AspectJ两种主流框架，各有不同的特点和适用场景。
> 
> 5. **Spring AOP与AspectJ的区别**
>    - Spring AOP基于动态代理，默认使用JDK或CGLIB。
>    - AspectJ采用编译时或加载时织入，性能更高，支持更复杂的切面功能。
> 
> 6. **编译织入、运行织入的区别**
>    - 编译织入在编译阶段插入切面代码。
>    - 运行织入在运行时动态生成代理类，Spring AOP采用这种方式。
> 
> 在整个思考过程中，我需要确保每个概念都解释清晰，并且提供足够的例子或对比，帮助理解。同时，补充相关的知识点，如反射的应用场景、AOP的核心概念（切面、连接点等），以及不同织入方式的优缺点。
> 
> 在编写回答时，我会按照问题顺序逐一展开，用简洁明了的语言进行解释，避免使用过于专业的术语，或者如果用了，就给出简单的定义。同时，提供示例代码或对比表格，帮助读者更好地理解和记忆。
> 
> 最后，确保整体结构清晰，逻辑连贯，让这位开发人员能够系统地掌握这些知识点，提升在面试中的表现。
</details>
### 什么是反射？优缺点？
<p><strong>反射机制：</strong><br>
反射是Java中一个强大的功能，允许程序在运行时检查和操作类、方法和字段等元数据。通过反射，开发者可以动态地调用类的方法，访问私有成员变量，甚至创建对象，而无需在编译时知道这些信息。</p>
<p><strong>优点：</strong></p>
<ol>
<li>
<p><strong>灵活性高：</strong><br>
反射使得代码更具灵活性，可以在运行时动态决定如何操作类和对象，而不需要提前编写大量重复的代码。</p>
</li>
<li>
<p><strong>框架实现：</strong><br>
许多Java框架（如Spring、Hibernate）利用反射机制来实现依赖注入、ORM等功能。通过反射，这些框架能够动态地创建对象并调用方法，而无需预先知道具体的类结构。</p>
</li>
<li>
<p><strong>调试和测试工具：</strong><br>
反射在调试工具和单元测试框架中也非常有用，允许开发者动态检查和修改程序状态。</p>
</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>
<p><strong>性能开销大：</strong><br>
相对于直接使用类和方法，反射操作通常会带来额外的性能开销。动态解析类和方法会导致运行时效率降低。</p>
</li>
<li>
<p><strong>安全性问题：</strong><br>
反射允许访问私有成员变量和方法，这可能破坏封装性，导致代码维护困难，并增加潜在的安全风险。</p>
</li>
<li>
<p><strong>代码可读性和维护性差：</strong><br>
过度使用反射可能会使代码难以理解和维护。其他开发者可能难以立即理解反射代码的意图和实现细节。</p>
</li>
</ol>
<p><strong>应用场景举例：</strong></p>
<ul>
<li>
<p><strong>ORM框架（如Hibernate）：</strong><br>
通过反射访问对象的属性并生成相应的SQL语句。</p>
</li>
<li>
<p><strong>依赖注入容器（如Spring）：</strong><br>
反射用于动态创建对象并注入依赖。</p>
</li>
<li>
<p><strong>单元测试框架（如JUnit）：</strong><br>
使用反射调用被测类的方法，无需显式编写测试代码。</p>
</li>
</ul>
<hr>
<h3 id="jdk动态代理和cglib动态代理">JDK动态代理和CGLIB动态代理</h3>
<p><strong>JDK动态代理：</strong></p>
<ol>
<li>
<p><strong>原理：</strong><br>
基于<code>java.lang.reflect.Proxy</code>类，生成一个代理类。该代理类实现了指定的接口，并在运行时根据调用处理程序（InvocationHandler）来分派方法调用。</p>
</li>
<li>
<p><strong>特点：</strong></p>
<ul>
<li>只能为实现接口的类创建代理。</li>
<li>适用于基于接口的编程模型。</li>
</ul>
</li>
<li>
<p><strong>使用场景：</strong><br>
当目标对象实现了一个或多个接口时，JDK动态代理是首选方案。由于其内置支持，这种方式性能较好且易于使用。</p>
</li>
</ol>
<p><strong>CGLIB动态代理：</strong></p>
<ol>
<li>
<p><strong>原理：</strong><br>
使用ASM库动态生成目标类的子类，并在子类中覆盖方法以实现代理功能。</p>
</li>
<li>
<p><strong>特点：</strong></p>
<ul>
<li>不需要目标对象实现接口。</li>
<li>适用于没有接口的情况。</li>
</ul>
</li>
<li>
<p><strong>使用场景：</strong><br>
当目标对象没有实现任何接口，或者无法修改其代码来添加接口时，CGLIB动态代理是一个合适的选择。需要注意的是，由于生成子类的方式，CGLIB对某些情况（如final方法或类）有限制。</p>
</li>
</ol>
<p><strong>示例代码对比：</strong></p>
<h4 id="jdk动态代理">JDK动态代理：</h4>
<pre><code class="language-java">// 定义接口
public interface UserService {
    void doSomething();
}

// 实现类
public class UserServiceImpl implements UserService {
    @Override
    public void doSomething() {
        System.out.println(&quot;Doing something...&quot;);
    }
}

// 创建代理工厂
public class UserServiceProxyFactory {
    public static UserService createProxy(final UserService userService) {
        return (UserService) Proxy.newProxyInstance(
                UserService.class.getClassLoader(),
                new Class&lt;?&gt;[]{UserService.class},
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(&quot;Before method call&quot;);
                        Object result = method.invoke(userService, args);
                        System.out.println(&quot;After method call&quot;);
                        return result;
                    }
                });
    }
}
</code></pre>
<h4 id="cglib动态代理">CGLIB动态代理：</h4>
<pre><code class="language-java">// 目标类（无需实现接口）
public class UserServiceImpl {
    public void doSomething() {
        System.out.println(&quot;Doing something...&quot;);
    }
}

// 动态代理生成的子类将覆盖此方法
public class UserServiceProxy extends UserServiceImpl implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, Method proxyMethod) throws Throwable {
        System.out.println(&quot;Before method call&quot;);
        Object result = method.invoke(obj, args);
        System.out.println(&quot;After method call&quot;);
        return result;
    }

    public static UserServiceImpl createProxy() {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserServiceImpl.class);
        enhancer.setCallback(new UserServiceProxy());
        return (UserServiceImpl) enhancer.create();
    }
}
</code></pre>
<p><strong>选择哪种代理方式：</strong></p>
<ul>
<li>如果目标对象实现了接口，优先使用JDK动态代理。</li>
<li>如果目标对象没有实现接口，则必须使用CGLIB动态代理。</li>
</ul>
<hr>
<h3 id="什么是反射优缺点">什么是反射？优缺点？</h3>
<p><strong>总结：</strong></p>
<p>反射是Java中的一个强大机制，允许在运行时检查和操作类、方法和字段。它提供了高度的灵活性，但也带来了性能开销、安全性和维护性问题。在实际开发中，应根据具体需求选择是否使用反射，并权衡其利弊。</p>
<hr>
<h3 id="jdk动态代理-vs-cglib动态代理">JDK动态代理 vs CGLIB动态代理</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>JDK动态代理</th>
<th>CGLIB动态代理</th>
</tr>
</thead>
<tbody>
<tr>
<td>代理实现方式</td>
<td>实现接口，生成代理类</td>
<td>继承目标类，覆盖方法</td>
</tr>
<tr>
<td>是否需要接口</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>性能</td>
<td>较优</td>
<td>较差（生成子类的开销）</td>
</tr>
<tr>
<td>应用场景</td>
<td>接口编程模型</td>
<td>无接口或无法修改代码的情况</td>
</tr>
<tr>
<td>使用限制</td>
<td>仅支持接口</td>
<td>支持所有类，但无法处理final方法/类</td>
</tr>
</tbody>
</table>
<p><strong>选择建议：</strong></p>
<ul>
<li>当目标对象实现了一个或多个接口时，优先使用JDK动态代理。</li>
<li>当目标对象未实现任何接口且无法修改其代码时，考虑使用CGLIB动态代理。</li>
</ul>
<hr>
<h3 id="如何有效利用反射和动态代理">如何有效利用反射和动态代理？</h3>
<ol>
<li>
<p><strong>避免过度使用反射：</strong></p>
<ul>
<li>尽量在编译时解决类和方法的调用，减少运行时解析带来的性能开销。</li>
</ul>
</li>
<li>
<p><strong>合理选择动态代理方式：</strong></p>
<ul>
<li>根据目标对象是否实现接口，选择JDK或CGLIB动态代理。</li>
</ul>
</li>
<li>
<p><strong>使用框架提供的工具：</strong></p>
<ul>
<li>框架如Spring已经封装了反射和动态代理的复杂性，开发者可以专注于业务逻辑而不必直接处理底层细节。</li>
</ul>
</li>
<li>
<p><strong>确保代码可维护性：</strong></p>
<ul>
<li>使用反射和动态代理时，添加足够的注释和文档，方便其他开发者理解和维护代码。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结">总结</h3>
<ul>
<li>
<p><strong>反射</strong>提供了在运行时操作类和对象的强大能力，但也带来了性能、安全性和维护性的挑战。</p>
</li>
<li>
<p><strong>JDK动态代理</strong>适用于实现接口的场景，具有较高的性能和灵活性。</p>
</li>
<li>
<p><strong>CGLIB动态代理</strong>则适合无法修改代码且目标对象未实现接口的情况，但需注意其限制条件。</p>
</li>
</ul>
<p>在实际开发中，合理使用反射和动态代理可以提升代码的灵活性和复用性，同时避免过度依赖这些技术以保证系统的稳定性和可维护性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用排序算法实现及单例模式]]></title>
        <id>https://suxiaomu.top/UceADWQqWT/</id>
        <link href="https://suxiaomu.top/UceADWQqWT/">
        </link>
        <updated>2023-06-17T01:30:22.000Z</updated>
        <summary type="html"><![CDATA[<p>快速排序</p>
]]></summary>
        <content type="html"><![CDATA[<p>快速排序</p>
<!-- more -->
<pre><code class="language-java"></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程之线程池]]></title>
        <id>https://suxiaomu.top/CeZNMgta1/</id>
        <link href="https://suxiaomu.top/CeZNMgta1/">
        </link>
        <updated>2023-06-16T13:15:05.000Z</updated>
        <summary type="html"><![CDATA[<p>线程池就是创建若干个可执行的线程放入一个池（容器）中，有任务需要处理时，会提交到线程池中的任务队列，处理完之后线程并不会被销毁，而是仍然在线程池中等待下一个任务。</p>
]]></summary>
        <content type="html"><![CDATA[<p>线程池就是创建若干个可执行的线程放入一个池（容器）中，有任务需要处理时，会提交到线程池中的任务队列，处理完之后线程并不会被销毁，而是仍然在线程池中等待下一个任务。</p>
<!-- more -->
<h2 id="为什么要用线程池">为什么要用线程池？</h2>
<p>Java 中创建一个线程，需要调用操作系统内核的 API，操作系统要为线程分配一系列的资源，成本很高，所以线程是一个重量级的对象，应该避免频繁创建和销毁。<br>
使用线程池就能很好地避免频繁创建和销毁。</p>
<p>为了减少在创建和销毁线程上所花的时间和对系统资源的消耗，解决资源不足的问题。</p>
<p>如果不适用线程池，有可能造成系统创建大量同类线程而消耗内存挥着”过度切换“问题。</p>
<h2 id="四种线程池">四种线程池</h2>
<ul>
<li><strong>SingleThreadPool</strong>：单个线程线程池，core = max =1，拿一个任务用一个线程</li>
<li><strong>FixedThreadPool</strong>：指定大小的固定大小线程池，core=max, 都不能回收，无界队列</li>
<li><strong>CachedThreadPool</strong>：core是0，所有的线程都可回收，无界队列</li>
<li><strong>ScheduledThreadPool</strong> ： 定时任务专用的线程池</li>
</ul>
<p>问题</p>
<ul>
<li><strong>FixedThreadPool</strong>和<strong>SingleThreadPool</strong>：允许的<strong>请求队列</strong>长度为Interger.MAX_VALUE，可能会堆积大量请求，造成OOM；</li>
<li><strong>CachedThreadPool</strong>和<strong>ScheduledThreadPool</strong>：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量线程，造成OOM。</li>
</ul>
<h2 id="线程池参数">线程池参数？</h2>
<ul>
<li>corePoolSize：核心线程数量，定义了最小可以同时运行的线程数量，没有任务也不会被回收。</li>
<li>maximumPoolSize：当线程数量<strong>大于核心线程数</strong>，且队列中存放的任务达到队列容量的时候，继续创建线程。</li>
<li>keepAliveTime：超过corePoolSize之后”临时线程“的存活时间。</li>
<li>timeUnit：单位</li>
<li>workQueue：当新任务来的时候，保存未执行的任务。大于corePoolSize时进入阻塞队列等待。</li>
<li>threadFactory：线程工厂，用来创建线程，默认就行</li>
<li>RejectdExecutionHandler handler：拒绝策略，线程数量达到maximumPoolSize大小，且workQueue也塞满的情况下，线程池调用handler拒绝策略来处理请求。</li>
</ul>
<p>线程池运行流程：<br>
1.线程池创建core数量的核心线程准备接受任务<br>
2.core满了之后，任务进入阻塞队列<br>
3.阻塞队列慢之后，开新线程执行，开到max<br>
4.到max之后，max - core 数量的空闲线程会在keepAliveTime指定时间后销毁，最后保持到core数量的线程<br>
5.max也满了，还有新任务进来，就开始执行线程池的拒绝策略</p>
<p>举例：<br>
一个线程池，core5 , max 20 queue 50， 100并发：<br>
首先5个直接执行。接下来50个进入队列排队，再多开15个继续执行，现在70个被安排了，剩余30个任务进入到默认的拒绝策略处理。</p>
<h2 id="线程池拒绝策略">线程池拒绝策略：</h2>
<ul>
<li>
<p>AbortPolicy：默认拒绝策略，直接抛异常</p>
</li>
<li>
<p>DiscardPolicy：直接抛弃不处理。</p>
</li>
<li>
<p>DiscardOldestPolicy：丢弃队列中最老的任务。</p>
</li>
<li>
<p>CallerRunsPolicy：将任务分配给当前执行execute方法的线程来执行</p>
<p>自定义拒绝策略：实现<code>RejectedExecutionHandler</code>接口，可以实现友好的拒绝策略。包括但不限于：将数据存入数据库，用日志处理等。</p>
</li>
</ul>
<p>JDK 的并发工具包里还有一个静态线程池工厂类 Executors，可以方便地创建线程池，但是由于 Executors 创建的线程池内部很多地方用到了无界任务队列，在高并发场景下，无界任务队列会接收过多的任务对象，导致 JVM 抛出OutOfMemoryError，整个 JVM 服务崩溃，影响严重。所以很多公司已经不建议使用 Executors 去创建线程。</p>
<h2 id="线程池包含哪些状态">线程池包含哪些状态？</h2>
<p>线程池的5种状态：RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED。</p>
<p>见 ThreadPoolExecutor 源码</p>
<pre><code class="language-java">// runState is stored in the high-order bits
private static final int RUNNING    = -1 &lt;&lt;COUNT_BITS;
private static final int SHUTDOWN   =  0 &lt;&lt;COUNT_BITS;
private static final int STOP       =  1 &lt;&lt;COUNT_BITS;
private static final int TIDYING    =  2 &lt;&lt;COUNT_BITS;
private static final int TERMINATED =  3 &lt;&lt;COUNT_BITS;
</code></pre>
<ol>
<li>
<p>RUNNING：<br>
线程池一旦被创建，就处于 RUNNING 状态，任务数为 0，能够接收新任务，对已排队的任务进行处理。</p>
</li>
<li>
<p>SHUTDOWN：<br>
不接收新任务，但能处理已排队的任务。调用线程池的 shutdown() 方法，线程池由 RUNNING 转变为 SHUTDOWN 状态。</p>
</li>
<li>
<p>STOP：<br>
不接收新任务，不处理已排队的任务，并且会中断正在处理的任务。调用线程池的 shutdownNow() 方法，线程池由(RUNNING 或 SHUTDOWN ) 转变为 STOP 状态。</p>
</li>
<li>
<p>TIDYING：<br>
SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态，会执行 terminated() 方法。线程池中的 terminated() 方法是空实现，可以重写该方法进行相应的处理。<br>
线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池就会由 SHUTDOWN 转变为 TIDYING 状态。<br>
线程池在 STOP 状态，线程池中执行中任务为空时，就会由 STOP 转变为 TIDYING 状态。</p>
</li>
<li>
<p>TERMINATED：<br>
线程池彻底终止。线程池在 TIDYING 状态执行完 terminated() 方法就会由 TIDYING 转变为 TERMINATED 状态。</p>
</li>
</ol>
<h2 id="线程池关闭方法">线程池关闭方法</h2>
<h4 id="1shutdown">1.shutdown()</h4>
<ul>
<li>有序关闭，已提交任务继续执行</li>
<li>不接受新任务</li>
</ul>
<h4 id="2-shutdownnow">2、shutdownNow()</h4>
<ul>
<li>尝试停止所有正在执行的任务</li>
<li>停止等待执行的任务，并返回等待执行的任务列表</li>
</ul>
<h4 id="3-awaitterminationlong-timeout-timeunit-unit">3、awaitTermination(long timeout, TimeUnit unit)</h4>
<ul>
<li>收到关闭请求后，所有任务执行完成、超时、线程被打断，阻塞直到三种情况任意一种发生</li>
<li>参数可以设置超时时间与超时单位</li>
<li>线程池关闭返回 true；超过设置时间未关闭，返回 false</li>
</ul>
<h5 id="总结">总结</h5>
<pre><code>- 调用 shutdown() 和 shutdownNow() 方法关闭线程池，线程池都无法接收新的任务
- shutdown() 方法会继续执行正在执行未完成的任务；shutdownNow() 方法会尝试停止所有正在执行的任务
- shutdown() 方法没有返回值；shutdownNow() 方法返回等待执行的任务列表
- awaitTermination(long timeout, TimeUnit unit) 方法可以获取线程池是否已经关闭，需要配合 shutdown() 使用
- shutdownNow() 不一定能够立马结束线程池，该方法会尝试停止所有正在执行的任务，通过调用 Thread.interrupt() 方法来实现的，如果线程中没有 sleep() 、wait()、Condition、定时锁等应用，interrupt() 方法是无法中断当前的线程的。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程之synchronized关键字]]></title>
        <id>https://suxiaomu.top/D7arNdIEW/</id>
        <link href="https://suxiaomu.top/D7arNdIEW/">
        </link>
        <updated>2023-06-15T13:13:40.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>synchronized通过对象内部的一个叫做<strong>监视器锁</strong>的东西来实现的。</p>
<p>监视器锁本身依赖于操作系统底层的<strong>互斥锁Mutex Lock</strong>来实现的，<strong>同步代码块</strong>是通过<code>monitorenter</code> 和<code>moniterexit</code> 指令来获取线程的执行权。<strong>同步方法</strong>是通过加<code>ACC_SYNCHONIZED</code> 标识获取线程的执行权。</p>
<p>操作系统实现线程之间的切换需要从<strong>用户态</strong>转换到<strong>核心态</strong>，成本很高，状态转换要花费比较长的时间。</p>
<p>这就是synchronized效率低的原因。这种依赖于操作系统MutexLock实现的锁成为<strong>重量级锁</strong>。</p>
<h3 id="synchronized-vs-volatile">synchronized v.s. volatile</h3>
<p>Volatile：内存可见(不保证原子性，不保证互斥性)；防止CPU指令重排(内存屏障)</p>
<p>扩展：</p>
<p>如何保证内存可见？</p>
<blockquote>
<p><strong>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</strong></p>
</blockquote>
<p>什么是内存屏障？</p>
<blockquote>
<p><strong>MM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证</strong>。</p>
</blockquote>
<h3 id="happens-before规则">happens-before规则</h3>
<p>happens-before表示的是前一个操作的结果对于后续操作是可见的，它是一种表达多个线程之间对于内存的可见性。所以我们可以认为在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须要存在happens-before关系。这两个操作可以是同一个线程，也可以是不同的线程。</p>
<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程之锁与锁升级]]></title>
        <id>https://suxiaomu.top/u2MONV7zD/</id>
        <link href="https://suxiaomu.top/u2MONV7zD/">
        </link>
        <updated>2023-06-13T13:05:39.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="java中的锁">java中的锁</h2>
<p>synchronized 关键字锁定代码库<br>
可重入锁 java.util.concurrent.lock.ReentrantLock<br>
可重复读写锁 java.util.concurrent.lock.ReentrantReadWriteLock</p>
<h3 id="可重入锁">可重入锁</h3>
<ul>
<li>指在同一个线程在外层方法获取锁的时候，进入内层方法会自动获取锁。JDK 中基本都是可重入锁，避免死锁的发生。上面提到的常见的锁都是可重入锁。</li>
</ul>
<h3 id="公平锁-非公平锁">公平锁 / 非公平锁</h3>
<ul>
<li>公平锁：多个线程按照申请锁的顺序依次获得锁，如<code>java.util.concurrent.lock.ReentrantLock.FairSync</code></li>
<li>非公平锁：指多个线程获取锁的顺序并不是按照申请锁的顺序，而是有可能后申请的线程优先获得锁。如<code>synchronized</code>，<code>java.util.concurrent.lock.ReentrantLock.NonfairSync</code>等</li>
</ul>
<h3 id="独享锁-共享锁">独享锁 / 共享锁</h3>
<ul>
<li>独享：指锁一次只能被一个线程所持有。如<code>synchronized</code> ，<code>java.util.concurrent.lock.ReentrantLock</code> 都是独享锁</li>
<li>共享：指锁可以被多个线程所持有。<code>ReadWriteLock</code> 返回的 <code>ReadLock</code>  就是共享锁</li>
</ul>
<h3 id="悲观锁-乐观锁">悲观锁 / 乐观锁</h3>
<ul>
<li>悲观锁：一律会对代码进行加锁，<code>synchronized</code> ，<code>java.util.concurrent.lock.ReentrantLock</code> 都是悲观锁</li>
<li>乐观锁：默认不会进行并发修改，通常不断采取CAS算法不断尝试更新</li>
<li>悲观锁适合写多读少的场景 ，乐观锁适合读多写少的场景</li>
</ul>
<h3 id="粗粒度锁-细粒度锁">粗粒度锁 / 细粒度锁</h3>
<ul>
<li>粗粒度锁，就是把执行的代码块都锁定</li>
<li>细粒度锁，就是锁住尽可能小的代码块，<code>java.util.concurrent.ConcurrentHashMap</code>  中的分段锁就是一种细粒度锁</li>
<li>粗粒度锁和细粒度锁是相对的，没有什么标准</li>
</ul>
<h3 id="偏向锁-轻量级锁-重量级锁">偏向锁 / 轻量级锁 / 重量级锁</h3>
<ul>
<li>JDK 1.5 之后新增锁的升级机制，提升性能。</li>
<li>通过 synchronized 加锁后，一段同步代码一直被同一个线程所访问，那么该线程获取的就是偏向锁</li>
<li>偏向锁被一个其他线程访问时，Java 对象的偏向锁就会升级为轻量级锁</li>
<li>再有其他线程会以自旋的形式尝试获取锁，不会阻塞，自旋一定次数仍然未获取到锁，就会膨胀为重量级锁</li>
</ul>
<h3 id="自旋锁">自旋锁</h3>
<ul>
<li>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式来获取锁。这样的好处是减少线程的上下文切换消耗，缺点是循环占有，可能会CPU空转，浪费资源。</li>
</ul>
<h2 id="锁的升级">锁的升级</h2>
<p>锁的状态由低到高：</p>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p>只能升级，不能降级。</p>
<table>
<thead>
<tr>
<th style="text-align:center">锁状态</th>
<th style="text-align:center">存储内容</th>
<th style="text-align:center">标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无锁</td>
<td style="text-align:center">对象的hashCode，对象分代年龄，是否是偏向锁(0)</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">偏向锁</td>
<td style="text-align:center">偏向线程ID，偏向时间戳，对象分代年龄，是否偏向锁(1)</td>
<td style="text-align:center">01</td>
</tr>
<tr>
<td style="text-align:center">轻量级锁</td>
<td style="text-align:center">指向栈中锁记录的指针</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">重量级锁</td>
<td style="text-align:center">指向互斥量的指针</td>
<td style="text-align:center">11</td>
</tr>
</tbody>
</table>
<p>锁的对比</p>
<table>
<thead>
<tr>
<th style="text-align:center">锁</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">偏向锁</td>
<td style="text-align:center">加解锁不需要额外消耗，和执行非异步方法相比仅存在纳秒级差距。</td>
<td style="text-align:center">若线程之间存在竞争，会代带来额外的锁撤销的消耗(撤销偏向锁会Stop The World)</td>
<td style="text-align:center">使用于只有一个线程访问同步代码场景</td>
</tr>
<tr>
<td style="text-align:center">轻量级锁</td>
<td style="text-align:center">竞争的线程不会阻塞，提高了系统的响应速度</td>
<td style="text-align:center">始终得不到锁的竞争线程，不断自旋会消耗CPU</td>
<td style="text-align:center">追求响应速度，同步代码块执行速度非常快</td>
</tr>
<tr>
<td style="text-align:center">重量级锁</td>
<td style="text-align:center">线程竞争不使用自旋，不会消耗CPU</td>
<td style="text-align:center">线程阻塞，响应时间慢</td>
<td style="text-align:center">追求吞吐量，同步块执行速度较慢</td>
</tr>
</tbody>
</table>
<p>锁如何升级</p>
<ul>
<li>
<p>无锁</p>
<p>无锁是指线程通过无限循环来执行更新操作，如果执行成功就退出循环，如果执行失败（有其他线程更新了值），则继续执行，直到成功为止。CAS操作就属于无锁。如果从性能的角度来看，无锁状态的性能是非常高的。</p>
</li>
<li>
<p>偏向锁</p>
<p><strong>偏向锁的前提假设是当一个线程获取锁，后面还有大概率该线程还会需要继续持有这把锁</strong> 。</p>
<p>当有另外一个线程区尝试获取这个锁的时候，偏向模式就宣告结束。</p>
<blockquote>
<p>虚拟机启用偏向锁的参数<code>-XX:UseBiasedLocking</code>。如果当前偏向锁已启动，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为<code>01</code>，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁的同步块时，虚拟机都可以不用再进行同步操作了。</p>
</blockquote>
</li>
<li>
<p>轻量级锁</p>
<p><strong>当开始有锁的竞争了，那么偏向锁就会升级到轻量级锁；</strong></p>
<p>当获取锁冲突多，时间越长的时候，线程肯定无法继续在这里死等了，所以只好先挂起，然后等前面获取锁的线程释放了锁之后，再开启下一轮的锁竞争，而这种形式就是我们的重量级锁。</p>
<p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为<code>01</code>状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。</p>
<p>然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为<code>00</code>，即表示此对象处于轻量级锁定状态。 <strong>轻量级锁的前提假设是对于绝大部分的锁，在整个同步周期内都是不存在竞争的，通过CAS操作来避免时候互斥锁的开销</strong></p>
<p>关于自旋锁：</p>
<blockquote>
<p>自旋锁是一种通过让线程不释放当前的CPU执行一个忙循环，来尝试获取锁的方式。 <strong>自旋锁的前提假设是锁被其它线程占用的时间很短</strong> 。如果其它线程占用锁的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而带来性能上的浪费。自旋次数的默认值是<code>10</code>次，用户可以通过使用参数<code>-XX:PreBlockSpin</code>来更改。</p>
</blockquote>
</li>
<li>
<p>重量级锁</p>
<p>当有两个及以上的线程争用同一个锁，那么轻量级锁就不再有效，要膨胀为重量级锁。锁标志的状态值变为<code>10</code>，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<blockquote>
<ul>
<li>偏向锁只有设置了<code>-XX:UseBiasedLocking</code>参数才会存在</li>
<li>假设启用了偏向锁，对象头的锁标志位是<code>01</code>（和未锁定状态一样），但是存储的内容是偏向线程ID、偏向时间戳</li>
<li>当线程获取偏向锁是通过CAS操作将对象头中存储的偏向线程ID更新为当前线程的ID</li>
<li>对象是否被锁定是指对象头是否指向线程的锁记录（Lock Record）</li>
<li>只有是轻量级锁或者重量级锁时对象才会被锁定</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程之如何保证多线程程序运行的安全性]]></title>
        <id>https://suxiaomu.top/Q0uGuAKPB/</id>
        <link href="https://suxiaomu.top/Q0uGuAKPB/">
        </link>
        <updated>2023-06-13T11:04:35.000Z</updated>
        <summary type="html"><![CDATA[<p>原子性，可见性，顺序性如何保证？</p>
]]></summary>
        <content type="html"><![CDATA[<p>原子性，可见性，顺序性如何保证？</p>
<!-- more -->
<h2 id="多线程程序运行的安全问题体现在">多线程程序运行的安全问题体现在？</h2>
<ul>
<li>
<p>原子性<br>
一个或多个操作在CPU执行的过程中不被中断的特性</p>
</li>
<li>
<p>可见性<br>
一个线程对共享变量的修改，另外一个线程能立刻看到</p>
</li>
<li>
<p>有序性<br>
程序执行的顺序按照代码的先后顺序执行</p>
<h2 id="导致原因">导致原因</h2>
<ul>
<li>线程切换带来的原子性问题</li>
<li>缓存导致的可见性问题</li>
<li>编译优化带来的有序性问题</li>
</ul>
</li>
</ul>
<h2 id="解决方法">解决方法</h2>
<ul>
<li>JDK Atomic原子类、synchronized、LOCK，可解决原子性问题</li>
<li>synchronized、volatile、LOCK，可以解决可见性问题</li>
<li>Happens-Before规则可以解决有序性问题</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程之进程与线程]]></title>
        <id>https://suxiaomu.top/moQ_RMGta/</id>
        <link href="https://suxiaomu.top/moQ_RMGta/">
        </link>
        <updated>2023-06-12T13:34:44.000Z</updated>
        <summary type="html"><![CDATA[<p>老生常谈之进程与线程</p>
]]></summary>
        <content type="html"><![CDATA[<p>老生常谈之进程与线程</p>
<!-- more -->
<h2 id="进程">进程</h2>
<ul>
<li>程序执行时的一个实例</li>
<li>每个进程都有独立的内存地址空间</li>
<li>是操作系统进行资源分配和调度的基本单位</li>
<li>进程里的堆，是一个进程中最大的一块内存，被进程中的所有线程共享，进程创建时分配，主要存放new创建的对象实例</li>
<li>进程的方法区，是用来存放进程中的代码片段的，是线程共享的</li>
<li>在多线程OS中，进程不是一个可执行的实体，即一个进程至少创建一个线程去执行代码</li>
</ul>
<h2 id="线程">线程</h2>
<ul>
<li>进程中的一个实体</li>
<li>进程的一个执行路径</li>
<li>CPU调度和分派的基本单位</li>
<li>现成本身是不会独立存在的</li>
<li>当前线程CPU时间片用完后，会让出CPU等下次轮到自己再执行</li>
<li>操作系统不会单独为线程分配内存，线程组之间只能共享所属进程的资源</li>
<li>现成只拥有在运行中必不可少的资源(比如程序计数器、栈)</li>
<li>线程的程序计数器就是为了记录该线程在让出CPU时候的执行地址，待再次时间片分配到自己时继续执行</li>
<li>每个线程有自己的栈资源，用于存储该线程的局部变量和调用栈帧，其他线程无权访问</li>
</ul>
<h2 id="关系">关系</h2>
<ul>
<li>一个程序至少一个进程，一个进程至少有一个线程；进程中的多个线程是互相共享资源的</li>
<li>Java中启动main函数的时候就启动了一个JVM的进程，main函数所在的线程就是主线程。</li>
<li>多个线程共享进程的堆空间和方法区资源，每个线程有自己的程序计数器和栈资源。</li>
</ul>
<h2 id="区别">区别</h2>
<ul>
<li>本质：进程是操作系统进行资源调度和分配的基本单位；线程是任务调度和执行的基本单位</li>
<li>内存分配：系统在运行的时候会为每个进程分配不同的内存空间，建立数据表来维护代码段、堆栈段和数据段；除了 CPU 外，系统不会为线程分配内存，线程所使用的资源来自其所属进程的资源</li>
<li>资源拥有：进程之间的资源是独立的，无法共享；同一进程的所有线程共享本进程的资源，如内存，CPU，IO 等</li>
<li>开销：每个进程都有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行程序计数器和栈，线程之间切换的开销小</li>
<li>通信：进程间通信 以IPC（管道，信号量，共享内存，消息队列，文件，套接字等）方式通信 ；同一个进程下，线程间可以共享全局变量、静态变量等数据进行通信，做到同步和互斥，以保证数据的一致性</li>
<li>调度和切换：线程上下文切换比进程上下文切换更快，代价更小</li>
<li>执行过程：每个进程都有一个程序执行的入口，顺序执行序列；线程不能够独立执行，必须依存在应用程序中，由程序的多线程控制机制控制</li>
<li>健壮性：每个进程之间的资源是独立的，当一个进程崩溃时，不会影响其他进程；同一进程的线程共享此线程的资源，当一个线程发生崩溃时，此进程也会发生崩溃，稳定性差，容易出现共享与资源竞争产生的各种问题，如死锁等</li>
</ul>
<h2 id="为什么要有线程">为什么要有线程</h2>
<p>每个进程都有自己的地址空间，即进程空间。操作系统为了避免为每个请求都创建进程，引入线程</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[异步化事务型消息模型]]></title>
        <id>https://suxiaomu.top/1T9C5Piq8/</id>
        <link href="https://suxiaomu.top/1T9C5Piq8/">
        </link>
        <updated>2023-03-10T13:04:55.000Z</updated>
        <summary type="html"><![CDATA[<p>事务型消息及分布式事务理论</p>
]]></summary>
        <content type="html"><![CDATA[<p>事务型消息及分布式事务理论</p>
<!--more-->
<h2 id="异步化事务型消息模型">异步化事务型消息模型</h2>
<h3 id="事务型消息">事务型消息</h3>
<p>分布式事务消息适用于所有对数据最终一致性有强需求的场景。</p>
<ul>
<li>半事务消息：暂不能投递的消息，发送方已经成功地将消息发送到了消息队列RocketMQ版服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半事务消息。</li>
<li>消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，消息队列RocketMQ版服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit或是Rollback），该询问过程即消息回查。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/1579264061/p177406.png" alt="流程" loading="lazy"></figure>
<p>事务型消息交互流程</p>
<ol>
<li>发送方将半事务消息发送至消息队列RocketMQ版服务端。</li>
<li>消息队列RocketMQ版服务端将消息持久化成功之后，向发送方返回Ack确认消息已经发送成功，此时消息为半事务消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（Commit或是Rollback），服务端收到Commit状态则将半事务消息标记为可投递，订阅方最终将收到该消息；服务端收到Rollback状态则删除半事务消息，订阅方将不会接受该消息。</li>
</ol>
<p>事务消息回查步骤如下：</p>
<ol>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行操作。</li>
</ol>
<h5 id="rocketmq消息的最终状态">RocketMQ消息的最终状态</h5>
<h2 id="分布式事务">分布式事务</h2>
<h3 id="base-理论">BASE 理论</h3>
<ul>
<li>Basically Available(基本可用)</li>
<li>Soft state(软状态)</li>
<li>Eventually consistent(最终一致性)</li>
</ul>
<p><strong>基本可用</strong> 是指不追求强可用性，而且强调系统基本能够一直运行对外提供服务。当分布式系统遇到不可预估的故障时，允许一定程度上的不可用，比如：对请求进行限流排队，对非核心服务进行降级。</p>
<p><strong>软状态</strong> 是指允许系统中的数据存在中间状态，而不是事务的原子性：要么全部成功，要不全部不成功。</p>
<p><strong>最终一致性</strong> 是指数据不可能一直都是软状态，必须在一个时间期限之后达到各个节点的一致性，在此之后，所有的节点的数据都是一致的，系统达到最终一致性。</p>
<p><code>BASE</code> 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KafKa实现ClickHouse增量同步数据]]></title>
        <id>https://suxiaomu.top/CbG54JdMQ/</id>
        <link href="https://suxiaomu.top/CbG54JdMQ/">
        </link>
        <updated>2022-02-22T14:22:23.000Z</updated>
        <summary type="html"><![CDATA[<p>KafKa与ClickHouse</p>
]]></summary>
        <content type="html"><![CDATA[<p>KafKa与ClickHouse</p>
<!-- more -->
<hr>
<h2 id="kafka下载与安装">Kafka下载与安装</h2>
<h3 id="下载">下载</h3>
<p>官网下载 :</p>
<p><a href="https://kafka.apache.org/downloads">Apache Kafka</a></p>
<p>确保已经安装jdk8+环境，使用<code>javac</code>命令测试</p>
<h3 id="安装">安装</h3>
<p>解压</p>
<pre><code class="language-shell">tar -xzvf kafka_2.12-3.1.0.tgz -C /opt
</code></pre>
<p>建议建立软连接</p>
<pre><code class="language-shell">ln -s ./kafka_2.12-3.1.0 kafka/
</code></pre>
<p>查看目录结构</p>
<pre><code class="language-shell">▶ ll /opt/kafka/
total 64K
drwxr-xr-x. 3 root root 4.0K Jan 12 17:04 bin
drwxr-xr-x. 3 root root 4.0K Mar  8 14:36 config
drwxr-xr-x. 2 root root 8.0K Mar  8 14:32 libs
-rw-r--r--. 1 root root  15K Jan 12 17:01 LICENSE
drwxr-xr-x. 2 root root  262 Jan 12 17:04 licenses
drwxr-xr-x. 2 root root  237 Mar  8 14:41 logs
-rw-r--r--. 1 root root  28K Jan 12 17:01 NOTICE
drwxr-xr-x. 2 root root   44 Jan 12 17:04 site-docs
</code></pre>
<h2 id="kafka常用命令">Kafka常用命令</h2>
<h3 id="管理">管理</h3>
<pre><code class="language-shell">#启动zookeeper
bin/zookeeper-server-start.sh -daemon config/zookeeper.properties 

#启动Kafka
bin/kafka-server-start.sh -daemon config/server.properties

## 创建topic（1个分区，2个副本）
bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test

## 创建topic (新版本)kafka版本 &gt;= 2.2
bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test

## 分区扩容
# kafka版本 &lt; 2.2
bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic topic1 --partitions 2

# kafka版本 &gt;= 2.2
bin/kafka-topics.sh --bootstrap-server broker_host:port --alter --topic topic1 --partitions 2

## 删除topic
bin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic test
</code></pre>
<h3 id="查询">查询</h3>
<pre><code class="language-shell">## 查询集群描述
bin/kafka-topics.sh --describe --zookeeper 127.0.0.1:2181

## topic列表查询
bin/kafka-topics.sh --list --zookeeper localhost:2181

## topic列表查询（支持0.9版本+）
bin/kafka-topics.sh --list --bootstrap-server localhost:9092

## 新消费者列表查询（支持0.9版本+）
bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server localhost:9092 --list

## 新消费者列表查询（支持0.10版本+）
bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list

## 显示某个消费组的消费详情（仅支持offset存储在zookeeper上的）
bin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zookeeper localhost:2181 --group test

## 显示某个消费组的消费详情（0.9版本 - 0.10.1.0 之前）
bin/kafka-consumer-groups.sh --new-consumer --bootstrap-server localhost:9092 --describe --group test-consumer-group

## 显示某个消费组的消费详情（0.10.1.0版本+）
bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group
</code></pre>
<h3 id="生产和消费">生产和消费</h3>
<pre><code>## 生产者
bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test

## 消费者
bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test

## 新生产者（支持0.9版本+）
bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test --producer.config config/producer.properties

## 新消费者（支持0.9版本+）
bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --from-beginning --consumer.config config/consumer.properties --topic test

## kafka-verifiable-consumer.sh（消费者事件，例如：offset提交等）
bin/kafka-verifiable-consumer.sh --broker-list localhost:9092 --topic test --group-id groupName

## 高级点的用法
bin/kafka-simple-consumer-shell.sh --brist localhost:9092 --topic test --partition 0 --offset 1234  --max-messages 10
</code></pre>
<hr>
<h2 id="clickhouse使用kafka外表进行数据的增量更新">ClickHouse使用Kafka外表进行数据的增量更新</h2>
<h3 id="kafka">kafka:</h3>
<ol>
<li>创建topic</li>
</ol>
<pre><code>bin/kafka-topic --create --bootstrap-server localhost:9092 --replication-factors 1 --partitions 1 --topic tdf
</code></pre>
<h3 id="clickhouse">clickhouse:</h3>
<ol>
<li>创建Kafka消费表(Kafka引擎)</li>
</ol>
<pre><code class="language-sql">CREATE TABLE default.toll_detail_final_kafka
(
    `id` Int64,
    `toll_detail_id` Int64,
    `order_id` String,
    `toll_duty_id` String,
    `park_id` Int64,
    `licence_plate` String,
    `brand` String,
    `toll_man_name` String,
    `toll_man_id` Int64,
    `in_time` Nullable(DateTime64(3, 'Asia/Shanghai')) ,
    `out_time` Nullable(DateTime64(3, 'Asia/Shanghai')) ,
    `event_time` DateTime64(3, 'Asia/Shanghai'),
    `in_location` String,
    `in_camera_id` Int64,
    `out_location` String,
    `out_camera_id` Int64,
    `fee_expected` Decimal(15,2),
    `fee_cash` Decimal(15,2),
    `fee_third_part` Decimal(15,2),
    `fee_third_part_real` Decimal(15,2),
    `fee_member_point` Decimal(15,2),
    `fee_member_benefit` Decimal(15,2),
    `fee_etc` Decimal(15,2),
    `fee_third_part_deduction` Decimal(15,2),
    `fee_cash_by_pos` Decimal(15,2),
    `fee_online` Decimal(15,2),
    `fee_coupon` Decimal(15,2),
    `paper_coupon_fee` Decimal(15,2),
    `elec_coupon_fee` Decimal(15,2),
    `paper_coupon_hours` Int64,
    `elec_coupon_hours` Int64,
    `free_reason` String,
    `free_amount` Decimal(15,2),
    `fee_balance` Decimal(15,2),
    `owner_id` Int64,
    `owner_name` String,
    `car_type` String,
    `note` String,
    `lift_by_hand` Int32,
    `in_exception_type` String,
    `out_exception_type` String,
    `status` Int32,
    `updated_at` DateTime64(3, 'Asia/Shanghai'),
    `created_at` DateTime64(3, 'Asia/Shanghai'),
    `description` String,
    `fee_exception` Decimal(15,2),
    `fee_reserved1` Decimal(15,2),
    `fee_reserved2` Decimal(15,2)
)
ENGINE = Kafka()
SETTINGS 
kafka_broker_list = '120.0.0.1:9092',
kafka_topic_list = 'toll_detail_final',
kafka_group_name = 'tdfConsumerGroup',
kafka_format = 'JSONEachRow',
kafka_skip_broken_messages = 10;
</code></pre>
<ol start="2">
<li>创建实体表实际存数据(MergeTree引擎)</li>
</ol>
<p>已经创建的tdf和tt表(以toll_detail_final表举例)</p>
<pre><code class="language-sql">CREATE TABLE default.toll_detail_final
(
 `id` Int64,
 `toll_detail_id` Int64,
 `order_id` String,
 `toll_duty_id` String,
 `park_id` Int64,
 `licence_plate` String,
 `brand` String,
 `toll_man_name` String,
 `toll_man_id` Int64,
 `in_time` Nullable(DateTime64(3, 'Asia/Shanghai')),
 `out_time` Nullable(DateTime64(3, 'Asia/Shanghai')),
 `event_time` Nullable(DateTime64(3, 'Asia/Shanghai')),
 `in_location` String,
 `in_camera_id` Int64,
 `out_location` String,
 `out_camera_id` Int64,
 `fee_expected` Decimal(15, 2),
 `fee_cash` Decimal(15, 2),
 `fee_third_part` Decimal(15, 2),
 `fee_third_part_real` Decimal(15, 2),
 `fee_member_point` Decimal(15, 2),
 `fee_member_benefit` Decimal(15, 2),
 `fee_etc` Decimal(15, 2),
 `fee_third_part_deduction` Decimal(15, 2),
 `fee_cash_by_pos` Decimal(15, 2),
 `fee_online` Decimal(15, 2),
 `fee_coupon` Decimal(15, 2),
 `paper_coupon_fee` Decimal(15, 2),
 `elec_coupon_fee` Decimal(15, 2),
 `paper_coupon_hours` Int64,
 `elec_coupon_hours` Int64,
 `free_reason` String,
 `free_amount` Decimal(15, 2),
 `fee_balance` Decimal(15, 2),
 `owner_id` Int64,
 `owner_name` String,
 `car_type` String,
 `note` String,
 `lift_by_hand` Int32,
 `in_exception_type` String,
 `out_exception_type` String,
 `status` Int32,
 `updated_at` DateTime64(3, 'Asia/Shanghai'),
 `created_at` DateTime64(3, 'Asia/Shanghai'),
 `description` String,
 `fee_exception` Decimal(15, 2),
 `fee_reserved1` Decimal(15, 2),
 `fee_reserved2` Decimal(15, 2)
)
ENGINE = ReplacingMergeTree(updated_at)
ORDER BY id
SETTINGS index_granularity = 8192
</code></pre>
<ol start="3">
<li>创建物化视图，联系kafka消费表和实体表</li>
</ol>
<pre><code class="language-sql">create materialized view view_tdf_consumer TO toll_detail_final as
select id,toll_detail_id,order_id,toll_duty_id,park_id,licence_plate,brand,toll_man_name,toll_man_id,in_time,out_time,event_time,in_location,in_camera_id,out_location,out_camera_id,fee_expected,fee_cash,fee_third_part,fee_third_part_real,fee_member_point,description,fee_etc,fee_third_part_deduction,fee_cash_by_pos,fee_online,fee_coupon,paper_coupon_fee,elec_coupon_fee,paper_coupon_hours,elec_coupon_hours,free_reason,free_amount,fee_balance,owner_id,owner_name,car_type,note,lift_by_hand,in_exception_type,out_exception_type,status,updated_at,created_at,fee_member_benefit,fee_exception,fee_reserved1,fee_reserved2 from toll_detail_final_kafka;
</code></pre>
<ol start="4">
<li>关联/卸载视图</li>
</ol>
<pre><code class="language-shell"># 卸载视图:
detach view view_tdf_consumer;

# 关联视图:
attach table view_tdf_consumer;
</code></pre>
<p>kafka生产消息，kafka消费表会拉取消息，物化视图将它转换为实体表中的记录。</p>
<p>消息样式举例：</p>
<pre><code class="language-json">{&quot;fee_exception&quot;:100.0,&quot;out_exception_type&quot;:&quot;&quot;,&quot;paper_coupon_fee&quot;:0.0,&quot;fee_cash&quot;:0.0,&quot;out_camera_id&quot;:1538,&quot;owner_id&quot;:0,&quot;description&quot;:&quot;&quot;,&quot;created_at&quot;:1649317245039,&quot;fee_reserved1&quot;:0.0,&quot;fee_etc&quot;:0.0,&quot;fee_reserved2&quot;:0.0,&quot;elec_coupon_hours&quot;:0,&quot;out_location&quot;:&quot;车道2&quot;,&quot;car_type&quot;:&quot;visitor&quot;,&quot;fee_expected&quot;:100.0,&quot;fee_balance&quot;:0.0,&quot;updated_at&quot;:1649315050000,&quot;toll_man_name&quot;:&quot;&quot;,&quot;fee_online&quot;:0.0,&quot;elec_coupon_fee&quot;:0.0,&quot;in_camera_id&quot;:1539,&quot;id&quot;:5816289,&quot;in_exception_type&quot;:&quot;&quot;,&quot;brand&quot;:&quot;&quot;,&quot;in_location&quot;:&quot;车道1&quot;,&quot;free_amount&quot;:0.0,&quot;out_time&quot;:1649223909000,&quot;fee_third_part_real&quot;:0.0,&quot;fee_member_benefit&quot;:0.0,&quot;owner_name&quot;:&quot;&quot;,&quot;toll_duty_id&quot;:&quot;&quot;,&quot;paper_coupon_hours&quot;:0,&quot;toll_detail_id&quot;:0,&quot;park_id&quot;:2803,&quot;fee_third_part&quot;:0.0,&quot;fee_third_part_deduction&quot;:0.0,&quot;licence_plate&quot;:&quot;贵Z005A1&quot;,&quot;fee_coupon&quot;:0.0,&quot;in_time&quot;:1649176380000,&quot;fee_cash_by_pos&quot;:0.0,&quot;fee_member_point&quot;:0.0,&quot;order_id&quot;:&quot;C2803153920220406003300143&quot;,&quot;event_time&quot;:1649314955000,&quot;lift_by_hand&quot;:0,&quot;status&quot;:2}
</code></pre>
]]></content>
    </entry>
</feed>